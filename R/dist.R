#### Custom distribution shell
# if(F){
#   custom_model <- list(
#     name = '',               # this should be the shortened name that appears after d/p in the distribution functions i.e. "norm" in dnorm
#     pars = c('','',''),      # a vector of each parameter name, exactly as they are stated in the d/p functions i.e c('mean','sd') for norm
#     location= c(),           # IMPORTANT: specifies which parameter should vary based on the covariates in the model. Can usually omit shape /
#                              #  true-locations (like minimum or boundary parameters). This also is a key part of specifying AFT/PH interpretation of your model
#     transforms = c(),        # a vector of functions, one for each parameter, that transform the respective parameter into the real line. If param1 must be >0, log(param1) would be real
#     inv.transforms=c(),      # a vector of functions which transform the real values back to the original scale. exp(log(param1) returns to the original range of param1
#     inits = function(t){},   # a declared function which takes the time variable, and outputs initial estimates for the parameters. Ideally, estimates are based off of t somehow, but can be simple ints
#     p = pdist,               # by default, flexsurv looks for the d/p functions using the <name> object above, but the fssg function will use these declared p/d's instead
#     d = ddist,               #
#     h = hdist,               # May as well include the hazard functions as well!
#     H = Hdist,               #
#     fullname = ''            # this longer name is used in fssg to better label the distribution in outputs and console tracking
#   )
# }



#' FFSG_DIST_FORMAT
#'
#' flexsurv allows for the creating of custom distributions, which must follow a specific format to use the flexsurv functions.
#' FSSG uses a modified version of this formatting, which specifies the relevant distribution functions directly.
#'
#' FSSG distributions should be specified as a list, with the following attributes.
#'
#' @param name Simple short hand name for the relevant distribution. flexsurv will search for the distribution functions using this name by default if the functions aren't explicitly defined. E.g. 'norm' for pnorm, dnorm, etc.
#' @param pars Vector of parameter names which will be provided to the relevant distribution functions.
#' @param location Name of the parameter which should be allowed to vary based on covariates.
#' The name 'location' is an artifact of the original flexsurv methodology, where it was assumed that the distributions were from a location-scale family.
#' flexsurv does provide the ability to allow for more than one parameter to vary through the 'anc' option, however this has not been adapted into fssg at this time.
#' @param transforms Vector of the functions which should be used to scale each parameter to the real number line.
#' If a parameter must be positive, then 'log' would scale the parameter to the real line.
#' This is used to pass parameters through to the optimization function.
#' If no transformation is needed, use 'identity'.
#' @param inv.transforms Vector of the inverse transformation functions for parameters. E.g. If transforms is 'log', inv.transforms would be 'exp'.
#' @param inits Function which will take a vector of times t and provide the initial parameter estimates.
#' Ideally these should be estimated using the times from the relevant dataset, but can also be arbitrary initial values such as 1.
#' @param d Density function of the relevant distribution, such as dnorm.
#' If not supplied, flexsurv will search the global environment for a p-function using the name paramater.
#' If one is not found, flexsurv will attempt to search for a hazard function instead (hnorm).
#' If this fails, flexsurv will not be able to model.
#' @param p Distribution function of the relevant distribution, such as pnorm.
#' If not supplied, flexsurv will search the global environment for a p-function using the name paramater.
#' In the case that one is not found, then flexsurv will estimate one using integration, which will slow the process considerably.
#' @param q Quantile function for the relevant distribution, such as qnorm.
#' fssg provides a helper function (quantilify) to approximate q functions based on a p function.
#'
#' @param h Hazard function of the relevant distribution.
#' Not required, but may be supplied instead of a d function if that is preferred.
#' @param H Cumulative hazard function.
#' If not provided, and h function is being used for modeling, then flexsurv will estimate a cumulative hazard function, which will slow the process considerably.
#' @param fullname Alternative name for the distribution. This is used for naming of ooutputs generated by
#'
#' @references flexsurv vignette by Christopher H. Jackson https://cran.r-project.org/web/packages/flexsurv/vignettes/flexsurv.pdf
#'
#' @name fssg_dist_format
NULL



### Important note: flexsurv by default only varies one model parameter (what is specified in the distributions as `location`)
# We can make more than one parameter vary though, using the anc parameter in flexsurvreg
# Example: anc = list(shape1 = ~ var1 + var2, shape2 = ~ var3)
# It may be worth adding in some anc options in the dist-list...


#' fssg Helper Functions
#'
#' Couple of functions that extrapolate the S, h, and H functions based on pdf/cdf
#'
#' S<dist> = 1-p<dist>
#' h<dist> = d<dist> / S<dist>
#' H<dist> = -log(S<dist>)
#' q<dist> = quantile function (p<dist>)
#'
#' @param d_function Density function. E.g. dnorm.
#' @param p_function Distribution function. E.g. pnorm.
#'
#' @returns A new function of the desired type with the same parameters as the input functions.
#' @name helper
NULL

#' @export
#' @rdname helper
survivify <- function(p_function){
  force(p_function)  # ensure it's evaluated in the parent environment
  function(...) {
    1 - p_function(...)
  }
}

#' @export
#' @rdname helper
hazardify <- function(d_function, p_function){
  force(d_function)
  force(p_function)
  function(x, ...){
    fx <- d_function(x, ...)
    Fx <- p_function(q=x, ...)
    fx/ (1-Fx)
  }
}

#' @export
#' @rdname helper
cumhazardify <- function(p_function){
  force(p_function)
  function(x, ...){
    sx <- 1 - p_function(q=x,...)
    -log(sx)
  }
}


#' @export
#' @rdname helper
quantilify <- function(p_function){
  force(p_function)
  function(p, ...) {
    lower = -1e6
    upper = 1e100
    # for distributions with limited domain, adjust lower bound (handles most cases)
    lower_init <- if (p_function(0, ...) == 0) 0 else lower
    sapply(p,
      function(pi) {
        # handle edge cases
        if(is.na(pi)){return(NA_real_)}
        if(pi<0||pi>1){return(NaN)}
        if(pi==0){return(-Inf)}
        if(pi==1){return(Inf)}
        stats::uniroot(
          function(x) p_function(x, ...) - pi,
          lower = lower_init,
          upper = upper
        )$root
      }
    )
  }
}



#' Compiles list of available distributions
#'
#' @returns a list of all possible distributions
#'
#' @export
fssg_dist_list <- function(){

  ### Beta Prime
  fssg_betapr <- list(
    name = 'betapr',
    pars= c('shape1','shape2','scale'),
    location='scale',
    transforms= c(log,log,log),
    inv.transforms= c(exp,exp,exp),
    inits= function(t){c(3, 2, 1)},  # can be improved
    d = extraDistr::dbetapr,
    p = extraDistr::pbetapr,
    q = quantilify(extraDistr::pbetapr),
    h = hazardify(extraDistr::dbetapr,extraDistr::pbetapr),
    H = cumhazardify(extraDistr::pbetapr),
    fullname='beta_prime'
  )

  ### CAUCHY
  fssg_cauchy <- list(
    name='cauchy',
    pars= c('location','scale'), # location, shape
    location= c('scale'),
    transforms = c(identity, log),
    inv.transforms = c(identity, exp),
    inits = function(t){c(stats::median(t), stats::mad(t)+1e-8)},
    d = stats::dcauchy,
    p = stats::pcauchy,
    q = quantilify(stats::pcauchy),
    h = hazardify(stats::dcauchy,  stats::pcauchy),
    H = cumhazardify(stats::pcauchy),
    fullname='cauchy'
  )

  fssg_cauchy_loc <- list(  # alternative location based approach?
    name='cauchy',
    pars= c('location','scale'),
    location= c('location'),
    transforms = c(identity, log),
    inv.transforms = c(identity, exp),
    inits = function(t){c(stats::median(t), stats::mad(t)+1e-8)},
    d = stats::dcauchy,
    p = stats::pcauchy,
    q = quantilify(stats::pcauchy),
    h = hazardify(stats::dcauchy,  stats::pcauchy),
    H = cumhazardify(stats::pcauchy),
    fullname='cauchy_location'
  )

  ### CHI SQUARED
  fssg_chisq <- list(
    name='chisq',
    pars=c('df'),
    location=c('df'),
    transforms=c(log),
    inv.transforms=c(exp),
    inits = function(t){c(mean(t))},
    d = stats::dchisq,
    p = stats::pchisq,
    q = quantilify(stats::pchisq),
    h = hazardify(stats::dchisq, stats::pchisq),
    H = cumhazardify(stats::pchisq),
    fullname='chi_squared'
  )

  ### Dagum
  fssg_dagum <- list(
    name='dagum',
    pars= c('scale','shape1.a','shape2.p'), # scale, shape, shape
    location=c('scale'),
    transforms = c(log,log,log),
    inv.transforms = c(exp,exp,exp),
    inits = function(t){c(1,1,1)},
    p = VGAM::pdagum,
    d = VGAM::ddagum,
    q = quantilify(VGAM::pdagum),
    h = hazardify(VGAM::ddagum, VGAM::pdagum),
    H = cumhazardify(VGAM::pdagum),
    fullname='dagum'
  )

  ### Exponential logarithmic
  logit <- function(p){log(p/(1-p))}
  inv_logit <- function(x){return(1/(1+exp(-x)))}
  fssg_explog <- list(
    name = 'explog',
    pars = c('scale','shape'), # scale, shape
    location = 'scale',
    transforms = c(log, logit),
    inv.transforms = c(exp, inv_logit),
    inits=function(t){c(stats::median(t),.5)},
    p = VGAM::pexplog,
    d = VGAM::dexplog,
    q = quantilify(VGAM::pexplog),
    h = hazardify(VGAM::dexplog, VGAM::pexplog),
    H = cumhazardify(VGAM::pexplog),
    fullname='exponential_logarithmic'
  )

  ### Extreme value (generalized)
  fssg_extval <- list(
    name='gev',
    pars = c('mu','sigma','xi'), # loc, scale, shape
    location='sigma',
    transforms= c(identity, log, log),  # trying to make xi use log now, as the bounding is bad if <=0
    inv.transforms = c(identity, exp, exp),
    inits=function(t){c(1,1,1)},
    d = extraDistr::dgev,
    p = extraDistr::pgev,
    q = quantilify(extraDistr::pgev),
    h = hazardify(extraDistr::dgev, extraDistr::pgev),
    H = cumhazardify(extraDistr::pgev),
    fullname='generalized_extreme_value'
  )

  ### F distribution
  fssg_f <- list(
    name='f',
    pars = c('df1','df2'),
    location = ('df1'),
    transforms = c(log,log),
    inv.transforms = c(exp,exp),
    inits=function(t){c(stats::median(t),2)},
    d = stats::df,
    p = stats::pf,
    q = quantilify(stats::pf),
    h = hazardify(stats::df, stats::pf),
    H = cumhazardify(stats::pf),
    fullname='f'
  )

  ### Birnbaum - Saunders, specified as fatigue in extraDistr
  fssg_fatigue_shape <- list(
    name='fatigue',
    pars = c('alpha','beta'), # shape, scale,  (mu is omitted but can be location. set to zero by default)
    location= 'alpha',  # shape, PH effect?
    transforms = c(log,log),
    inv.transforms = c(exp,exp),
    inits = function(t){c(mean(t)/2,1)},
    d = extraDistr::dfatigue,
    p = extraDistr::pfatigue,
    q = quantilify(extraDistr::pfatigue),
    h = hazardify(extraDistr::dfatigue,extraDistr::pfatigue),
    H = cumhazardify(extraDistr::pfatigue),
    fullname='birnbaum_saunders_shape'
  )

  fssg_fatigue_scale <- list(
    name='fatigue',
    pars = c('alpha','beta'), # shape, scale,  (mu is omitted but can be location. set to zero by default)
    location= 'beta',  # we'll use scale: AFT effect?
    transforms = c(log,log),
    inv.transforms = c(exp,exp),
    inits = function(t){c(mean(t)/2,1)},
    d = extraDistr::dfatigue,
    p = extraDistr::pfatigue,
    q = quantilify(extraDistr::pfatigue),
    h = hazardify(extraDistr::dfatigue,extraDistr::pfatigue),
    H = cumhazardify(extraDistr::pfatigue),
    fullname='birnbaum_saunders_scale'
  )

  fssg_fatigue_shape_loc <- list(
    name='fatigue',
    pars = c('alpha','beta', 'mu'), # shape, scale, location
    location= 'alpha',  # we'll use shape: PH Effect?
    transforms = c(log,log, identity),
    inv.transforms = c(exp,exp, identity),
    inits = function(t){c(mean(t)/2,1,0)},
    d = extraDistr::dfatigue,
    p = extraDistr::pfatigue,
    q = quantilify(extraDistr::pfatigue),
    h = hazardify(extraDistr::dfatigue,extraDistr::pfatigue),
    H = cumhazardify(extraDistr::pfatigue),
    fullname='birnbaum_saunders_shape_location'
  )

  fssg_fatigue_scale_loc <- list(
    name='fatigue',
    pars = c('alpha','beta', 'mu'), # shape, scale, location
    location= 'beta',  # we'll use scale: AFT effect?
    transforms = c(log,log, identity),
    inv.transforms = c(exp,exp, identity),
    inits = function(t){c(mean(t)/2,1,0)},
    d = extraDistr::dfatigue,
    p = extraDistr::pfatigue,
    q = quantilify(extraDistr::pfatigue),
    h = hazardify(extraDistr::dfatigue,extraDistr::pfatigue),
    H = cumhazardify(extraDistr::pfatigue),
    fullname='birnbaum_saunders_scale_location'
  )


  ### folded normal parameterized on mean (location)
  fssg_fnorm_loc <- list(
    name= 'foldnorm',
    pars = c('mean','sd','a1','a2'),
    location = c('mean'),
    transforms = c(identity, log, identity, identity),
    inv.transforms = c(identity, exp, identity, identity),
    inits = function(t){c(mean(t),stats::sd(t),1,1)},
    d = VGAM::dfoldnorm,
    p = VGAM::pfoldnorm,
    q = quantilify(VGAM::pfoldnorm),
    h = hazardify(VGAM::dfoldnorm, VGAM::pfoldnorm),
    H = cumhazardify(VGAM::pfoldnorm),
    fullname='folded_normal_location'
  )

  ### Folded normal, parameterized on scale
  fssg_fnorm <- list(
    name= 'foldnorm',
    pars = c('mean','sd','a1','a2'),
    location = c('sd'),
    transforms = c(identity, log, identity, identity),
    inv.transforms = c(identity, exp, identity, identity),
    inits = function(t){c(mean(t),stats::sd(t),1,1)},
    d = VGAM::dfoldnorm,
    p = VGAM::pfoldnorm,
    q = quantilify(VGAM::pfoldnorm),
    h = hazardify(VGAM::dfoldnorm, VGAM::pfoldnorm),
    H = cumhazardify(VGAM::pfoldnorm),
    fullname='folded_normal'
  )

  ### Feller-Pareto (basically Pareto type five)
  fssg_fpareto <- list(
    name='fpareto',
    pars=c('min','shape1','shape2','shape3','rate'),
    location='rate',
    transforms=c(identity,log,log,log,log),
    inv.transforms=c(identity,exp,exp,exp,exp),
    inits=function(t){c(0,1,1,1,1)},
    d = actuar::dfpareto,
    p = actuar::pfpareto,
    q = quantilify(actuar::pfpareto),
    h = hazardify(actuar::dfpareto, actuar::pfpareto),
    H = cumhazardify(actuar::pfpareto),
    fullname='feller_pareto'
  )

  ### Frechet
  fssg_frech <- list(
    name='frechet',
    pars = c('lambda','mu','sigma'), # shape, location, scale
    location='sigma',
    transforms= c(log,identity,log),
    inv.transforms = c(exp,identity,exp),
    inits = function(t){c(1.5,min(t)-1,1)},
    d= extraDistr::dfrechet,
    p= extraDistr::pfrechet,
    q = quantilify(extraDistr::pfrechet),
    h = hazardify(extraDistr::dfrechet, extraDistr::pfrechet),
    H = cumhazardify(extraDistr::pfrechet),
    fullname='frechet'
  )

  ### Gamma-Gompertz
  fssg_gamgomp <- list(
    name='gamgomp',
    pars=c('b','sigma','beta'), # scale, shape, shape
    location='b',
    transforms=c(log,log,log),
    inv.transforms=c(exp,exp,exp),
    inits=function(t){c(1/max(t), 1, 1)},
    d = dgamgomp,
    p = pgamgomp,
    q = quantilify(pgamgomp),
    h = hazardify(dgamgomp, pgamgomp),
    H = cumhazardify(pgamgomp),
    fullname='gamma_gompertz'
  )

  ### Gumbel (basically log weibull)
  fssg_gumbel <- list(
    name='gumbel',
    pars=c('mu','sigma'), # location, scale
    location='sigma',
    transforms=c(identity, log),
    inv.transforms=c(identity, exp),
    inits=function(t){c(mean(t),(mean(t)/.577))},
    d = extraDistr::dgumbel,
    p = extraDistr::pgumbel,
    q = quantilify(extraDistr::pgumbel),
    h = hazardify(extraDistr::dgumbel, extraDistr::pgumbel),
    H = cumhazardify(extraDistr::pgumbel),
    fullname='gumbel'
  )

  ### Type-2 Gumbel
  fssg_gumbelII <- list(
    name='gumbelII',
    pars=c('scale','shape'),
    location='scale',
    transforms=c(identity, identity),
    inv.transforms=c(identity, identity),
    inits=function(t){c(1,1)},
    d = VGAM::dgumbelII,
    p = VGAM::pgumbelII,
    q = quantilify(VGAM::pgumbelII),
    h = hazardify(VGAM::dgumbelII, VGAM::pgumbelII),
    H = cumhazardify(VGAM::pgumbelII),
    fullname='gumbel_type_2'
  )

  # hyper tabastic
  fssg_hypertab_a <- list(
    name='hypertab',
    pars= c('a','b'),
    location= 'a',
    transforms= c(log,log),
    inv.transforms= c(exp,exp),
    inits= function(t){c(1,.1)},
    d = dhypertab,
    p = phypertab,
    q = quantilify(phypertab),
    h = hazardify(dhypertab, phypertab),
    H = cumhazardify(phypertab),
    fullname='hypertabastic'
  )

  fssg_hypertab_b <- list(
    name='hypertab',
    pars= c('a','b'),
    location= 'b',
    transforms= c(log,log),
    inv.transforms= c(exp,exp),
    inits= function(t){c(1,.1)},
    d = dhypertab,
    p = phypertab,
    q = quantilify(phypertab),
    h = hazardify(dhypertab, phypertab),
    H = cumhazardify(phypertab),
    fullname='hypertabastic'
  )

  ### Inverse Chi-squared
  fssg_invchisq <- list(
    name='invchisq',
    pars=c('nu'),
    location='nu',
    transforms=c(log),
    inv.transforms=c(exp),
    inits=function(t){c(3)},
    d = extraDistr::dinvchisq,
    p = extraDistr::pinvchisq,
    q = quantilify(extraDistr::pinvchisq),
    h = hazardify(extraDistr::dinvchisq, extraDistr::pinvchisq),
    H = cumhazardify(extraDistr::pinvchisq),
    fullname='inverse_chi_squared'
  )

  ### Inverse Gamma
  fssg_invgam <- list(
    name='invgamma',
    pars=c('alpha','beta'), # shape, scale
    location='beta',
    transforms=c(log,log),
    inv.transforms=c(exp,exp),
    inits=function(t){c(1,1)},
    d = extraDistr::dinvgamma,
    p = extraDistr::pinvgamma,
    q = quantilify(extraDistr::pinvgamma),
    h = hazardify(extraDistr::dinvgamma, extraDistr::pinvgamma),
    H = cumhazardify(extraDistr::pinvgamma),
    fullname='inverse_gamma'
  )

  ### Inverse Gaussian
  fssg_invgaus_loc <- list(
    name='inv.gaussian',
    pars=c('mu','lambda'), # mean, scale?
    location='mu',
    transforms=c(log,log),
    inv.transforms=c(exp,exp),
    inits=function(t){c(stats::median(t)/10, 2)},
    d = VGAM::dinv.gaussian,
    p = VGAM::pinv.gaussian,
    q = quantilify(VGAM::pinv.gaussian),
    h = hazardify(VGAM::dinv.gaussian, VGAM::pinv.gaussian),
    H = cumhazardify(VGAM::pinv.gaussian),
    fullname='inverse_gaussian_location'
  )

  fssg_invgaus <- list(
    name='inv.gaussian',
    pars=c('mu','lambda'), # mean, scale?
    location='lambda',
    transforms=c(log,log),
    inv.transforms=c(exp,exp),
    inits=function(t){c(stats::median(t)/10, 2)},
    d = VGAM::dinv.gaussian,
    p = VGAM::pinv.gaussian,
    q = quantilify(VGAM::pinv.gaussian),
    h = hazardify(VGAM::dinv.gaussian, VGAM::pinv.gaussian),
    H = cumhazardify(VGAM::pinv.gaussian),
    fullname='inverse_gaussian'
  )

  ### inverse Lindley
  fssg_invlind <- list(
    name= 'invlind',
    pars=c('theta'),
    location='theta',
    transforms=c(log),
    inv.transforms=c(exp),
    inits= function(t){c(1)},
    d = dinvlind,
    p = pinvlind,
    q = quantilify(pinvlind),
    h = hazardify(dinvlind, pinvlind),
    H = cumhazardify(pinvlind),
    fullname='inverse_lindley'
  )

  ### Laplace
  fssg_laplace <- list(
    name='laplace',
    pars=c('mu','sigma'), # location, scale
    location='sigma',
    transforms=c(identity, log),
    inv.transforms=c(identity, exp),
    inits=function(t){c(mean(t), sqrt(stats::var(t)/2))},
    d = extraDistr::dlaplace,
    p = extraDistr::plaplace,
    q = quantilify(extraDistr::plaplace),
    h = hazardify(extraDistr::dlaplace, extraDistr::plaplace),
    H = cumhazardify(extraDistr::plaplace),
    fullname='laplace'
  )

  ### Levy
  fssg_levy <- list(
    name='levy',
    pars=c('location','scale'), # location, scale
    location='scale',
    transforms=c(identity, log),
    inv.transforms=c(identity, exp),
    inits=function(t){c(0, stats::median(t))},
    d = VGAM::dlevy,
    p = VGAM::plevy,
    q = quantilify(VGAM::plevy),
    h = hazardify(VGAM::dlevy, VGAM::plevy),
    H = cumhazardify(VGAM::plevy),
    fullname='levy'
  )

  ### Lindley distribution
  fssg_lindley <- list(
    name= 'lind',
    pars=c('theta'),
    location='theta',
    transforms=c(log),
    inv.transforms=c(exp),
    inits= function(t){c(1/mean(t))},
    d = VGAM::dlind,
    p = VGAM::plind,
    q = quantilify(VGAM::plind),
    h = hazardify(VGAM::dlind, VGAM::plind),
    H = cumhazardify(VGAM::plind),
    fullname='lindley'
  )

  ### Log cauchy
  fssg_logcauchy_loc <- list(
    name='logcauchy',
    pars=c('mu','sigma'), # location, scale
    location='mu',
    transforms=c(identity, log),
    inv.transforms=c(identity, exp),
    inits=function(t){c(1,1)},
    d = dlogcauchy,
    p = plogcauchy,
    q = quantilify(plogcauchy),
    h = hazardify(dlogcauchy, plogcauchy),
    H = cumhazardify(plogcauchy),
    fullname='log_cauchy_location'
  )

  fssg_logcauchy <- list(
    name='logcauchy',
    pars=c('mu','sigma'),
    location='sigma',
    transforms=c(identity, log),
    inv.transforms=c(identity, exp),
    inits=function(t){c(1,1)},
    d = dlogcauchy,
    p = plogcauchy,
    q = quantilify(plogcauchy),
    h = hazardify(dlogcauchy, plogcauchy),
    H = cumhazardify(plogcauchy),
    fullname='log_cauchy'
  )

  ### Lomax
  fssg_lomax <- list(
    name='lomax',
    pars=c('lambda','kappa'), # scale, shape?
    location='lambda',
    transforms=c(log,log),
    inv.transforms=c(exp,exp),
    inits=function(t){c(stats::median(t),1)},
    d = extraDistr::dlomax,
    p = extraDistr::plomax,
    q = quantilify(extraDistr::plomax),
    h = hazardify(extraDistr::dlomax, extraDistr::plomax),
    H = cumhazardify(extraDistr::plomax),
    fullname='lomax'
  )

  ### Lomax shape parameter
  fssg_lomax_shape <- list(
    name='lomax',
    pars=c('lambda','kappa'), # scale, shape?
    location='kappa',
    transforms=c(log,log),
    inv.transforms=c(exp,exp),
    inits=function(t){c(stats::median(t),1)},
    d = extraDistr::dlomax,
    p = extraDistr::plomax,
    q = quantilify(extraDistr::plomax),
    h = hazardify(extraDistr::dlomax, extraDistr::plomax),
    H = cumhazardify(extraDistr::plomax),
    fullname='lomax_shape'
  )

  ### nakagami
  fssg_nakagami <- list(
    name='naka',
    pars=c('scale','shape'),
    location='scale',
    transforms=c(log,log),
    inv.transforms=c(exp,exp),
    inits=function(t){c(mean(t^2),(mean(t^2)^2)/stats::var(t^2))},
    d = VGAM::dnaka,
    p = VGAM::pnaka,
    q = quantilify(VGAM::pnaka),
    h = hazardify(VGAM::dnaka, VGAM::pnaka),
    H = cumhazardify(VGAM::pnaka),
    fullname='nakagami'
  )

  ### non central chi squared
  fssg_ncchisq <- list(
    name='chisq',
    pars=c('df','ncp'),  # shape scale
    location=c('ncp'),
    transforms=c(log, log),
    inv.transforms=c(exp,exp),
    inits = function(t){c(mean(t), 1)},
    d = stats::dchisq,
    p = stats::pchisq,
    q = quantilify(stats::pchisq),
    h = hazardify(stats::dchisq, stats::pchisq),
    H = cumhazardify(stats::pchisq),
    fullname='non_central_chi_squared'
  )

  ### noncentral F
  fssg_ncf <- list(
    name='f',
    pars = c('df1','df2', 'ncp'),
    location = ('ncp'),
    transforms = c(log,log,log),
    inv.transforms = c(exp,exp,exp),
    inits=function(t){c(stats::median(t),2,0)},
    d = stats::df,
    p = stats::pf,
    q = quantilify(stats::pf),
    h = hazardify(stats::df, stats::pf),
    H = cumhazardify(stats::pf),
    fullname='noncentral_f'
  )

  ### PARETO I , there's a few different versions of Pareto, all of which have almost never worked in testing
  fssg_pareto1 <- list(
    name='paretoI',
    pars=c('scale','shape'),
    location='scale',
    transforms=c(log,log),
    inv.transforms=c(exp,exp),
    inits=function(t){c(min(t)*.95,1)},
    d = VGAM::dparetoI,
    p = VGAM::pparetoI,
    q = quantilify(VGAM::pparetoI),
    h = hazardify(VGAM::dparetoI, VGAM::pparetoI),
    H = cumhazardify(VGAM::pparetoI),
    fullname='pareto_type_1'
  )

  ### Pareto II
  fssg_pareto2 <- list(
    name='paretoII',
    pars=c('location','scale','shape'),
    location='scale',
    transforms=c(identity,log,log),
    inv.transforms=c(identity,exp,exp),
    inits=function(t){c(0,min(t)*.95,1)},
    d = VGAM::dparetoII,
    p = VGAM::pparetoII,
    q = quantilify(VGAM::pparetoII),
    h = hazardify(VGAM::dparetoII, VGAM::pparetoII),
    H = cumhazardify(VGAM::pparetoII),
    fullname='pareto_type_2'
  )

  ### Pareto III
  fssg_pareto3 <- list(
    name='paretoIII',
    pars=c('location','scale','inequality'),
    location='scale',
    transforms=c(identity,log,log),
    inv.transforms=c(identity,exp,exp),
    inits=function(t){c(0,min(t)*.95,1)},
    d = VGAM::dparetoIII,
    p = VGAM::pparetoIII,
    q = quantilify(VGAM::pparetoIII),
    h = hazardify(VGAM::dparetoIII, VGAM::pparetoIII),
    H = cumhazardify(VGAM::pparetoIII),
    fullname='pareto_type_3'
  )

  ### Pareto IV
  fssg_pareto4 <- list(
    name='paretoIV',
    pars=c('location','scale','inequality','shape'),
    location='scale',
    transforms=c(identity,log,log,log),
    inv.transforms=c(identity,exp,exp,exp),
    inits=function(t){c(0,min(t)*95,1,2)},
    d=VGAM::dparetoIV,
    p=VGAM::pparetoIV,
    q = quantilify(VGAM::pparetoIV),
    h = hazardify(VGAM::dparetoIV, VGAM::pparetoIV),
    H = cumhazardify(VGAM::pparetoIV),
    fullname='pareto_type_4'
  )

  ### Rayleigh
  fssg_rayleigh <- list(
    name='rayleigh',
    pars=c('sigma'),
    location='sigma',
    transforms=c(log),
    inv.transforms=c(exp),
    inits=function(t){c(stats::median(t)/sqrt(2*log(2)))},
    d = extraDistr::drayleigh,
    p = extraDistr::prayleigh,
    q = quantilify(extraDistr::prayleigh),
    h = hazardify(extraDistr::drayleigh, extraDistr::prayleigh),
    H = cumhazardify(extraDistr::prayleigh),
    fullname='rayleigh'
  )

  ### Rice
  fssg_rice_loc <- list(
    name='rice',
    pars=c('sigma','vee'), # scale location?
    location='vee',
    transforms=c(log,log),
    inv.transforms=c(exp,exp),
    inits=function(t){c(stats::median(t), stats::sd(t))},
    d=VGAM::drice,
    p=VGAM::price,
    q = quantilify(VGAM::price),
    h = hazardify(VGAM::drice, VGAM::price),
    H = cumhazardify(VGAM::price),
    fullname='rice_location'
  )

  fssg_rice <- list(
    name='rice',
    pars=c('sigma','vee'), # scale, location?
    location='sigma',
    transforms=c(log,log),
    inv.transforms=c(exp,exp),
    inits=function(t){c(stats::median(t), stats::sd(t))},
    d = VGAM::drice,
    p = VGAM::price,
    q = quantilify(VGAM::price),
    h = hazardify(VGAM::drice, VGAM::price),
    H = cumhazardify(VGAM::price),
    fullname='rice'
  )

  ### Shifted Gompertz
  fssg_sgomp <- list(
    name='sgomp',
    pars=c('b','eta'),
    location='b',
    transforms=c(log,log),
    inv.transforms=c(exp,exp),
    inits=function(t){c(1/stats::median(t),stats::median(t))},
    d = extraDistr::dsgomp,
    p = extraDistr::psgomp,
    q = quantilify(extraDistr::psgomp),
    h = hazardify(extraDistr::dsgomp, extraDistr::psgomp),
    H = cumhazardify(extraDistr::psgomp),
    fullname='shifted_gompertz'
  )

  ### Singh Madalla (aka Burr-T12)
  fssg_sinmad  <- list(
    name='sinmad',
    pars = c('scale','shape1.a','shape3.q'), # scale, shape, shape
    location = ('scale'),
    transforms = c(log,log,log),
    inv.transforms = c(exp,exp,exp),
    inits=function(t){c(1,1,1)},
    d = VGAM::dsinmad,
    p = VGAM::psinmad,
    q = quantilify(VGAM::psinmad),
    h = hazardify(VGAM::dsinmad, VGAM::psinmad),
    H = cumhazardify(VGAM::psinmad),
    fullname='singh_maddala'
  )

  # scaled version inverse Chi Squared
  fssg_sinvchisq <- list(
    name='invchisq',
    pars=c('nu','tau'),
    location='tau',
    transforms=c(log, log),
    inv.transforms=c(exp, exp),
    inits=function(t){c(3, 1)},
    d = extraDistr::dinvchisq,
    p = extraDistr::pinvchisq,
    q = quantilify(extraDistr::pinvchisq),
    h = hazardify(extraDistr::dinvchisq, extraDistr::pinvchisq),
    H = cumhazardify(extraDistr::pinvchisq),
    fullname='scaled_inverse_chi_squared'
  )

  ### Truncated Pareto
  fssg_tpareto <- list(
    name='truncpareto',
    pars=c('lower','upper','shape'),
    location='shape',
    transforms=c(identity,identity, log),
    inv.transforms=c(identity, identity, exp),
    inits=function(t){c(min(t)-.1,max(t)+1, 1)},
    d = VGAM::dtruncpareto,
    p = VGAM::ptruncpareto,
    q = quantilify(VGAM::ptruncpareto),
    h = hazardify(VGAM::dtruncpareto, VGAM::ptruncpareto),
    H = cumhazardify(VGAM::ptruncpareto),
    fullname='truncated_pareto'
  )

  dist_list <-list(
        betaprime               = fssg_betapr,
        cauchy                  = fssg_cauchy,
        cauchy_location         = fssg_cauchy_loc,
        chisq                   = fssg_chisq,
        dagum                   = fssg_dagum,
        exp_log                 = fssg_explog,
        extr_val                = fssg_extval,
        f                       = fssg_f,
        fatigue                 = fssg_fatigue,
        fatigue_location        = fssg_fatigue_loc,
        fatigue_shape           = fssg_fatigue_shape,
        fatigue_shape_location  = fssg_fatigue_shape_loc,
        fold_norm               = fssg_fnorm,
        fold_norm_location      = fssg_fnorm_loc,
        feller_pareto           = fssg_fpareto,
        frechet                 = fssg_frech,
        gamgomp                 = fssg_gamgomp,
        gumbel                  = fssg_gumbel,
        gumbel_T2               = fssg_gumbelII,
        hypertab_a              = fssg_hypertab_a,
        hypertab_b              = fssg_hypertab_b,
        inv_chisq               = fssg_invchisq,
        inv_gamma               = fssg_invgam,
        inv_gaussian            = fssg_invgaus,
        inv_gaussian_location   = fssg_invgaus_loc,
        inv_lind                = fssg_invlind,
        laplace                 = fssg_laplace,
        levy                    = fssg_levy,
        lindley                 = fssg_lindley,
        log_cauchy              = fssg_logcauchy,
        log_cauchy_location     = fssg_logcauchy_loc,
        lomax                   = fssg_lomax,
        lomax_shape             = fssg_lomax_shape,
        nakagami                = fssg_nakagami,
        noncen_chisq            = fssg_ncchisq,
        noncen_f                = fssg_ncf,
        pareto_1                = fssg_pareto1,
        pareto_2                = fssg_pareto2,
        pareto_3                = fssg_pareto3,
        pareto_4                = fssg_pareto4,
        rayleigh                = fssg_rayleigh,
        rice                    = fssg_rice,
        rice_location           = fssg_rice_loc,
        shift_gomp              = fssg_sgomp,
        sinmad                  = fssg_sinmad,
        scale_inv_chisq         = fssg_sinvchisq,
        trunc_pareto            = fssg_tpareto
      )

  ### Removed for the time being
  # flexsurv_erlang,

  dist_list <- c(flexsurv::flexsurv.dists, dist_list)
  return(dist_list)
}


# note for jack, we can also export a list item by giving it a ##' @export before it. This would be an alternative to the functional approach above



#' Function to return a specific distribution object.
#'
#' @param dist_name Name of the distribution.
#' @returns Distribution object.
#' @export
fssg_dist <- function(dist_name){
  full_list <- fssg_dist_list()
  out <- NULL

  # we have three 'name' fields to check
  ### List-level name
  ### Object-attribute name
  ### Object-attribute fullname

  if(dist_name %in% names(full_list)){
    out <- full_list[[dist_name]]
  }
  for(i in full_list){
    if(dist_name %in% i$name | dist_name %in% i$fullname){
      out <- i
      break
    }
  }
  if(is.null(out)){stop('Could not find distribution by that name')}
  return(out)
}



#' Function to check if times can be calculated using the distribution with default inits.
#'
#' @param times 'Surv' object or numeric vector.
#' @param distribution A distribution object from fssg_dist_lists.
#' @returns Boolean indicator for success. If true, then all values can be calculated, and life is good.
#' @export
check_inits <- function(times, distribution){
  # accepts a vector or Surv object
  if(methods::is(times,'Surv')){
    times[,1] %>%
      as.numeric() %>%
      unique() %>%
      sort() -> time_vector
  }else{
    times %>%
      as.numeric() %>%
      unique() %>%
      sort() -> time_vector
  }

  # check distribution format: fssg and flexsurv distributions have different attributes
  if('d' %in% names(distribution)){
    dfunc <- distribution$d
  }else{
    dfunc <- get(paste('d', distribution$name, sep=''))
  }

  inits <- distribution$inits(time_vector)

  dfunc %>%
    formals() %>%
    names() %>%
    setdiff(c('log')) -> arguments


  dataframe <- data.frame(t = time_vector, p = NA, s = F)

  for(i in 1:length(time_vector)){
    as.list(c(time_vector[i], inits)) %>%
      stats::setNames(c(arguments)) %>%
      do.call(what=dfunc, args=.) -> dataframe$p[i]

    dataframe$s[i] <- is.finite(dataframe$p[i])
  }

  if(!any(dataframe$s)){
    message("Found some weird entries")

    dataframe %>%
      dplyr::filter(s=F) %>%
      print()
  }else{
    message("Works at every time point!")
    plot(
      x = dataframe$t[dataframe$s],
      y = dataframe$p[dataframe$s],
      type='o', main = 'Distribution with Default Inits',xlab = 'Times', ylab='Probability Density',sub=substitute(density_function))
  }

  return(any(dataframe$s))
}

